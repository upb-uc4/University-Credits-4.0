/**
  * UC4
  * This is the API for UC4.
  *
  * OpenAPI spec version: 0.0.1
  * Contact: apiteam@uc4.cs.upb.de
  *
  * NOTE: This class is auto generated by the swagger code generator program.
  * https://github.com/swagger-api/swagger-codegen.git
  * Do not edit the class manually.
  */

package de.upb.cs.uc4.course.model

import de.upb.cs.uc4.course.model.CourseLanguage.CourseLanguage
import de.upb.cs.uc4.course.model.CourseType.CourseType
import de.upb.cs.uc4.shared.client.SimpleError
import play.api.libs.json._

case class Course(
                   courseId: String,
                   courseName: String,
                   courseType: CourseType,
                   startDate: String,
                   endDate: String,
                   ects: Int,
                   lecturerId: String,
                   maxParticipants: Int,
                   currentParticipants: Int,
                   courseLanguage: CourseLanguage,
                   courseDescription: String
                 )
{
  def trim: Course = {
    copy(
      courseId,
      courseName.trim,
      courseType,
      startDate.trim,
      endDate.trim,
      ects,
      lecturerId.trim,
      maxParticipants,
      currentParticipants,
      courseLanguage,
      courseDescription.trim
    )
  }

  /** Checks if the course attributes correspond to agreed syntax and semantics
   *
   * @return response-code which gives detailed description of syntax or semantics violation
   */
  def validateCourseSyntax: Seq[SimpleError] = {

    val course = this
    val nameRegex = """[\s\S]*""".r // Allowed characters for coursename "[a-zA-Z0-9\\s]+".r
    val descriptionRegex = """[\s\S]*""".r // Allowed characters  for description
    val dateRegex = """(\d\d\d\d)-(\d\d)-(\d\d)""".r

    var errors = List[SimpleError]()

    if (course.courseName == "") {
      errors :+= SimpleError("courseName", "Course name must not be empty.")
    }
    if (!(nameRegex.matches(course.courseName))) {
      errors :+= SimpleError("courseName", "Course name must only contain [..].")
    }
    if (!CourseType.All.contains(course.courseType)) {
      errors :+= (SimpleError("courseType", "Course type must be one of [Lecture, Seminar, ProjectGroup]."))
    }
    if (!dateRegex.matches(course.startDate)) {
      errors :+= (SimpleError("startDate", "Start date must be of the following format \"yyyy-mm-dd\"."))
    }
    if (!dateRegex.matches(course.endDate)) {
      errors :+= (SimpleError("endDate", "End date must be of the following format \"yyyy-mm-dd\"."))
    }
    if (course.ects <= 0) {
      errors :+= (SimpleError("ects", "Ects must be a positive integer."))
    }
    if (course.maxParticipants <= 0) {
      errors :+= (SimpleError("maxParticipants", "Maximum Participants must be a positive integer."))
    }
    if (!CourseLanguage.All.contains(course.courseLanguage)) {
      errors :+= (SimpleError("courseLanguage", "Course Language must be one of" + CourseLanguage.All+"."))
    }
    if (!descriptionRegex.matches(course.courseDescription)) {
      errors :+= SimpleError("courseDescription", "Description must only contain Strings.")
    }
    errors
  }
}

object Course {
  implicit val format: Format[Course] = Json.format

}

